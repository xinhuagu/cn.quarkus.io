<!DOCTYPE html>
<html>





<head>
  <title>Quarkus - Simplified Hibernate ORM with Panache - 1.11</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta http-equiv="Content-Security-Policy" content="default-src https://dpm.demdex.net; script-src 'self' 'unsafe-eval' 'sha256-ANpuoVzuSex6VhqpYgsG25OHWVA1I+F6aGU04LoI+5s=' 'sha256-ipy9P/3rZZW06mTLAR0EnXvxSNcnfSDPLDuh3kzbB1w=' js.bizographics.com https://www.redhat.com https://static.redhat.com assets.adobedtm.com jsonip.com https://ajax.googleapis.com https://www.googletagmanager.com https://www.google-analytics.com https://use.fontawesome.com https://app.mailjet.com http://www.youtube.com http://www.googleadservices.com https://googleads.g.doubleclick.net https://dpm.demdex.net https://giscus.app; style-src 'self' https://fonts.googleapis.com https://use.fontawesome.com; img-src 'self' *; media-src 'self'; frame-src https://www.googletagmanager.com https://www.youtube.com https://embed.restream.io https://app.mailjet.com https://giscus.app; base-uri 'none'; object-src 'none'; form-action 'none'; font-src 'self' https://use.fontawesome.com https://fonts.gstatic.com;" />
  <script id="adobe_dtm" src="https://www.redhat.com/dtm.js" type="text/javascript"></script>
  <script src="/assets/javascript/highlight.pack.js" type="text/javascript"></script>
  <META HTTP-EQUIV='X-XSS-Protection' CONTENT="1; mode=block">
  <META HTTP-EQUIV='X-Content-Type-Options' CONTENT="nosniff">
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="Quarkus: Supersonic Subatomic Java">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@QuarkusIO"> 
  <meta name="twitter:creator" content="@QuarkusIO">
  <meta property="og:url" content="https://quarkus.io/version/1.11/guides/hibernate-orm-panache" />
  <meta property="og:title" content="Quarkus - Simplified Hibernate ORM with Panache - 1.11" />
  <meta property="og:description" content="Quarkus: Supersonic Subatomic Java" />
  <meta property="og:image" content="https://quarkus.io/assets/images/quarkus_card.png" />
  
  <link rel="canonical" href="https://quarkus.io/guides/hibernate-orm-panache">
  <link rel="shortcut icon" type="image/png" href="/favicon.ico" >
  <link rel="stylesheet" href="/guides/stylesheet/config.css" />
  <link rel="stylesheet" href="/assets/css/main.css?2021-07-29" />
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.1.0/css/all.css" integrity="sha384-lKuwvrZot6UHsBSfcMvOkWwlCMgc0TaWr+30HWe3a4ltaBwTZhyTEggF5tJv8tbt" crossorigin="anonymous">
  <link rel="alternate" type="application/rss+xml"  href="/feed.xml" title="Quarkus">
  <script src="/assets/javascript/goan.js" type="text/javascript"></script>
  <script src="/assets/javascript/hl.js" type="text/javascript"></script>
</head>

<body class="guides">
  <!-- Google Tag Manager (noscript) -->
  <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-NJWS5L"
  height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
  <!-- End Google Tag Manager (noscript) -->

  

<div class="grid-wrapper communitysite">
  <div class="grid__item width-12-12">The <a href="https://quarkus.io">English version of quarkus.io</a> is the official project site. Translated sites are community supported on a best-effort basis.</div>
</div>


  <div class="nav-wrapper">
  <div class="grid-wrapper">
    <div class="width-12-12">
      <input type="checkbox" id="checkbox" />
      <nav id="main-nav" class="main-nav">
  <div class="container">
    <div class="logo-wrapper">
        <a href="/"><img src="/assets/images/quarkus_logo_horizontal_rgb_600px_reverse.png" class="project-logo" title="Quarkus"></a>
    </div>
    <label class="nav-toggle" for="checkbox"> <i class="fa fa-bars"></i>
</label>
    <ul id="menu" class="menu">
      <li class="dropdown">
        <span href="/about/">关于<i class="fas fa-chevron-down">
</i></span>
        <ul class="submenu">
          <li><a href="/about" class="">QUARKUS是什么？</a></li>
          <li><a href="/container-first" class="">容器优先 </a></li>
          <li><a href="/continuum" class="">响应式</a></li>
          <li><a href="/developer-joy" class="">开发者的乐趣 </a></li>
          <li><a href="/kubernetes-native" class="">KUBERNETES 原生</a></li>
          <li><a href="/standards" class="">标准</a></li>
        </ul>
      </li>
      <li class="dropdown">
        <span href="/learn/">学习 <i class="fas
fa-chevron-down"></i></span>
        <ul class="submenu">
          <li><a href="/get-started" class="">入门</a></li>
          <li><a href="/guides" class="active" >指南</a></li>
          <li><a href="/qtips" class="">"Q" TIP视频</a></li>          
          <li><a href="/books" class="">书籍</a></li>
          </ul>
      </li>
      <li class="dropdown">
        <span href="/community/">社区 <i class="fas
fa-chevron-down"></i></span>
        <ul class="submenu">
          <li><a href="/support/" class="">支持</a></li>
          <li><a href="/blog" class="" >博客</a></li>
          <li><a href="/discussion" class="">讨论</a></li>
          <li><a href="/insights" class="" >播客</a></li>
          <li><a href="/events" class="">活动</a></li>
          <li><a href="/newsletter" class="">新闻</a></li>
          <li><a href="/publications" class="">发表</a></li>
          <li><a href="/awards" class="">获奖</a></li>
          </ul>
      </li>
      <li>
        <a href="https://code.quarkus.io" class="button-cta secondary
white">开始写代码</a>
      </li>
      <li class="dropdown">
        <span href="/language/"><div class="fas fa-globe langicon"></div><i class="fas fa-chevron-down"></i></span>
        <ul class="submenu">
          <li><a href="https://quarkus.io/" >OFFICIAL (ENGLISH)</a></li>
          <li><a href="https://es.quarkus.io/">ESPAÑOL</a></li>
          <li><a href="https://cn.quarkus.io/">简体中文</a></li>
          <li><a href="https://ja.quarkus.io/">日本語</a></li>
          </ul>
      </li>
    </ul>
  </div>
      </nav>
    </div>
  </div>
</div>

  <div class="content">
    



<div class="full-width-version-bg grey align-self">
  <div class="grid-wrapper">
    <div class="grid__item width-6-12">
      <p class="returnlink"><i class="fas fa-angle-left"></i><a href="/version/1.11/guides/">返回指南目录</a></p>
    </div>
    <div class="grid__item width-6-12 align-self-center text-right hide-mobile">
      <label id="guide-version-label">选择指南版本</label>
      <select id="guide-version-dropdown">
        
      
        
        
        
        
          
        <option value="main" >Main - SNAPSHOT</option>
        
        
      
        
        
        
        
          
        <option value="latest" >2.11 - Latest</option>
        
        
      
        
        
        
        
          
        <option value="2.7" >2.7</option>
        
        
      
        
        
        
        
          
        <option value="2.2" >2.2</option>
        
        
      
        
        
        
        
          
        <option value="1.11" selected>1.11</option>
        
        
      
    
      </select>
    </div>
  </div>
</div>

<div class="grid-wrapper guide">
  <div class="grid__item width-12-12 width-12-12-mobile">
    <h1 class="text-caps">Quarkus - Simplified Hibernate ORM with Panache </h1>
  </div>
  <div class="width-12-12">
    <div class="hide-mobile toc"><ul class="sectlevel1">
<li><a href="#第一一个例子">第一：一个例子</a></li>
<li><a href="#解决方案">解决方案</a></li>
<li><a href="#在hibernate-orm中配置panache">在Hibernate ORM中配置Panache</a></li>
<li><a href="#解决方案1使用active-record活动记录模式">解决方案1：使用active record（活动记录）模式</a>
<ul class="sectlevel2">
<li><a href="#定义你的实体">定义你的实体</a></li>
<li><a href="#最有用的操作">最有用的操作</a></li>
<li><a href="#添加实体方法">添加实体方法</a></li>
</ul>
</li>
<li><a href="#解决方案2使用资源库模式">解决方案2：使用资源库模式</a>
<ul class="sectlevel2">
<li><a href="#定义你的实体-2">定义你的实体</a></li>
<li><a href="#定义你的存储库">定义你的存储库</a></li>
<li><a href="#最有用的操作-2">最有用的操作</a></li>
</ul>
</li>
<li><a href="#高级查询">高级查询</a>
<ul class="sectlevel2">
<li><a href="#分页">分页</a></li>
<li><a href="#使用range而不是pages">使用range而不是pages</a></li>
<li><a href="#排序">排序</a></li>
<li><a href="#简化查询">简化查询</a></li>
<li><a href="#命名查询">命名查询</a></li>
<li><a href="#查询参数">查询参数</a></li>
<li><a href="#查询映射">查询映射</a></li>
</ul>
</li>
<li><a href="#多个持久化单元">多个持久化单元</a></li>
<li><a href="#事务">事务</a></li>
<li><a href="#锁管理">锁管理</a>
<ul class="sectlevel2">
<li><a href="#第一通过findbyid方法使用数据库锁">第一：通过findById()方法使用数据库锁。</a></li>
<li><a href="#第二通过find方法使用数据库锁">第二：通过find()方法使用数据库锁。</a></li>
</ul>
</li>
<li><a href="#自定义id">自定义ID</a></li>
<li><a href="#mocking">Mocking</a>
<ul class="sectlevel2">
<li><a href="#使用active-record模式">使用Active Record模式</a></li>
<li><a href="#使用资源库模式">使用资源库模式</a></li>
</ul>
</li>
<li><a href="#我们为什么简化hibernate-orm映射怎么做到的">我们为什么简化Hibernate ORM映射？怎么做到的？</a></li>
<li><a href="#在外部项目或jar中定义实体">在外部项目或jar中定义实体</a></li>
</ul></div>
    <div>
      <div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>Hibernate ORM是事实上的JPA实现，提供了全方位的对象关系映射（Object Relational Mapper，简称ORM）支持。它支持编写复杂的映射，但编写简单常用的映射却不够简便。Panache专注于简化Hibernate ORM实体，让你的Quarkus开发有趣。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="第一一个例子"><a class="anchor" href="#第一一个例子"></a>第一：一个例子</h2>
<div class="sectionbody">
<div class="paragraph">
<p>What we&#8217;re doing in Panache is allow you to write your Hibernate ORM entities like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Entity
public class Person extends PanacheEntity {
    public String name;
    public LocalDate birth;
    public Status status;

    public static Person findByName(String name){
        return find("name", name).firstResult();
    }

    public static List&lt;Person&gt; findAlive(){
        return list("status", Status.Alive);
    }

    public static void deleteStefs(){
        delete("name", "Stef");
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>你有注意到代码的紧凑性和可读性大大提高了吗？看起来很有趣吧？请继续阅读!</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>list()</code> 方法一开始可能会让人吃惊。它只需要接收HQL（JP-QL）查询语句的片段，并对查询语句其余部分进行上下文推断处理。这使得代码非常简明，但也不失可读性。
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
上面所描述的编码模式本质上是 <a href="https://www.martinfowler.com/eaaCatalog/activeRecord.html">Active Record模式</a> ，有时也称为实体模式。Panache也支持通过 <code>PanacheRepository</code> 使用更经典的 <a href="https://martinfowler.com/eaaCatalog/repository.html">Repository模式</a> 。
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="解决方案"><a class="anchor" href="#解决方案"></a>解决方案</h2>
<div class="sectionbody">
<div class="paragraph">
<p>我们建议您按照下一节的说明逐步创建应用程序。然而，您可以直接转到已完成的示例。</p>
</div>
<div class="paragraph">
<p>克隆 Git 仓库: <code>git clone <a href="https://github.com/quarkusio/quarkus-quickstarts.git" class="bare">https://github.com/quarkusio/quarkus-quickstarts.git</a></code> ，或下载一个 <a href="https://github.com/quarkusio/quarkus-quickstarts/archive/main.zip">存档</a> 。</p>
</div>
<div class="paragraph">
<p>该解决方案位于 <code>hibernate-orm-panache-quickstart</code> <a href="https://github.com/quarkusio/quarkus-quickstarts/tree/main/hibernate-orm-panache-quickstart">目录</a> 中。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="在hibernate-orm中配置panache"><a class="anchor" href="#在hibernate-orm中配置panache"></a>在Hibernate ORM中配置Panache</h2>
<div class="sectionbody">
<div class="paragraph">
<p>起步：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>在 <code>application.properties</code> 中添加你的设置。</p>
</li>
<li>
<p>annotate your entities with <code>@Entity</code></p>
</li>
<li>
<p>实体类改为继承 <code>PanacheEntity</code> 类（使用Repository模式时为可选操作）。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Follow the <a href="hibernate-orm#setting-up-and-configuring-hibernate-orm">Hibernate set-up guide for all configuration</a>.</p>
</div>
<div class="paragraph">
<p>在你的 <code>pom.xml</code> 文件中添加以下依赖项：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>the Panache JPA extension</p>
</li>
<li>
<p>JDBC驱动扩展 (如 <code>quarkus-jdbc-postgresql</code> , <code>quarkus-jdbc-h2</code> , <code>quarkus-jdbc-mariadb</code> , &#8230;&#8203;)</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependencies&gt;
    &lt;!-- Hibernate ORM specific dependencies --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
        &lt;artifactId&gt;quarkus-hibernate-orm-panache&lt;/artifactId&gt;
    &lt;/dependency&gt;

    &lt;!-- JDBC driver dependencies --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
        &lt;artifactId&gt;quarkus-jdbc-postgresql&lt;/artifactId&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后在 <code>application.properties</code> 中添加相关的配置属性。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties"># configure your datasource
quarkus.datasource.db-kind = postgresql
quarkus.datasource.username = sarah
quarkus.datasource.password = connor
quarkus.datasource.jdbc.url = jdbc:postgresql://localhost:5432/mydatabase

# drop and create the database at startup (use `update` to only update the schema)
quarkus.hibernate-orm.database.generation = drop-and-create</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="解决方案1使用active-record活动记录模式"><a class="anchor" href="#解决方案1使用active-record活动记录模式"></a>解决方案1：使用active record（活动记录）模式</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="定义你的实体"><a class="anchor" href="#定义你的实体"></a>定义你的实体</h3>
<div class="paragraph">
<p>要定义一个Panache实体类，只需继承 <code>PanacheEntity</code> ，增加 <code>@Entity</code> 注解，并将数据库列作为公共字段添加到实体类：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Entity
public class Person extends PanacheEntity {
    public String name;
    public LocalDate birth;
    public Status status;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这些公共字段可以添加任何JPA列注解。如果你不想持久化某个字段，给它增加 <code>@Transient</code> 注解即可。如果你需要编写访问器，可以：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Entity
public class Person extends PanacheEntity {
    public String name;
    public LocalDate birth;
    public Status status;

    // return name as uppercase in the model
    public String getName(){
        return name.toUpperCase();
    }

    // store all names in lowercase in the DB
    public void setName(String name){
        this.name = name.toLowerCase();
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>而且由于我们的字段访问重写，当你的用户读取 <code>person.name</code> ，他们实际上会调用你的 <code>getName()</code> 方法，类似的还有字段写入和设置器。这允许在运行时进行适当的封装，因为所有字段的调用都将被相应的getter/setter调用所取代。</p>
</div>
</div>
<div class="sect2">
<h3 id="最有用的操作"><a class="anchor" href="#最有用的操作"></a>最有用的操作</h3>
<div class="paragraph">
<p>编写实体后，可以执行以下最常见的操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// creating a person
Person person = new Person();
person.name = "Stef";
person.birth = LocalDate.of(1910, Month.FEBRUARY, 1);
person.status = Status.Alive;

// persist it
person.persist();

// note that once persisted, you don't need to explicitly save your entity: all
// modifications are automatically persisted on transaction commit.

// check if it's persistent
if(person.isPersistent()){
    // delete it
    person.delete();
}

// getting a list of all Person entities
List&lt;Person&gt; allPersons = Person.listAll();

// finding a specific person by ID
person = Person.findById(personId);

// finding a specific person by ID via an Optional
Optional&lt;Person&gt; optional = Person.findByIdOptional(personId);
person = optional.orElseThrow(() -&gt; new NotFoundException());

// finding all living persons
List&lt;Person&gt; livingPersons = Person.list("status", Status.Alive);

// counting all persons
long countAll = Person.count();

// counting all living persons
long countAlive = Person.count("status", Status.Alive);

// delete all living persons
Person.delete("status", Status.Alive);

// delete all persons
Person.deleteAll();

// delete by id
boolean deleted = Person.deleteById(personId);

// set the name of all living persons to 'Mortal'
Person.update("name = 'Mortal' where status = ?1", Status.Alive);</code></pre>
</div>
</div>
<div class="paragraph">
<p>所有 <code>list</code> 方法都有相对应的 <code>stream</code> 版本。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">try (Stream&lt;Person&gt; persons = Person.streamAll()) {
    List&lt;String&gt; namesButEmmanuels = persons
        .map(p -&gt; p.name.toLowerCase() )
        .filter( n -&gt; ! "emmanuel".equals(n) )
        .collect(Collectors.toList());
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>stream</code> 方法的运行需要事务。+ 由于这些stream开头的方法会执行I/O操作，所以应该通过 <code>close()</code> 方法或try-with-resource来关闭底层的 <code>ResultSet</code> 。否则你会看到来自Agroal的警告，它会为你关闭底层的 <code>ResultSet</code> 。
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="添加实体方法"><a class="anchor" href="#添加实体方法"></a>添加实体方法</h3>
<div class="paragraph">
<p>在实体本身内部的实体上添加自定义查询。这样，您和您的同事可以轻松找到它们，并且查询与他们操作的对象位于同一位置。将它们作为静态方法添加到实体类中是 Panache Active Record 方式。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Entity
public class Person extends PanacheEntity {
    public String name;
    public LocalDate birth;
    public Status status;

    public static Person findByName(String name){
        return find("name", name).firstResult();
    }

    public static List&lt;Person&gt; findAlive(){
        return list("status", Status.Alive);
    }

    public static void deleteStefs(){
        delete("name", "Stef");
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="解决方案2使用资源库模式"><a class="anchor" href="#解决方案2使用资源库模式"></a>解决方案2：使用资源库模式</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="定义你的实体-2"><a class="anchor" href="#定义你的实体-2"></a>定义你的实体</h3>
<div class="paragraph">
<p>使用Repository模式时，可以将实体类定义为普通的JPA实体。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Entity
public class Person {
    @Id @GeneratedValue private Long id;
    private String name;
    private LocalDate birth;
    private Status status;

    public Long getId(){
        return id;
    }
    public void setId(Long id){
        this.id = id;
    }
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    public LocalDate getBirth() {
        return birth;
    }
    public void setBirth(LocalDate birth) {
        this.birth = birth;
    }
    public Status getStatus() {
        return status;
    }
    public void setStatus(Status status) {
        this.status = status;
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
如果你不想自己定义实体的getter和setter方法，可以让实体类继承 <code>PanacheEntityBase</code> ，Quarkus将自动生成getter和setter方法。你也可以继承 <code>PanacheEntity</code> ，相比 <code>PanacheEntityBase</code> ，其优势是它还提供默认的ID字段。
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="定义你的存储库"><a class="anchor" href="#定义你的存储库"></a>定义你的存储库</h3>
<div class="paragraph">
<p>使用 Repository 模式时，通过实现 <code>PanacheRepository</code> 接口，你可以使用与Active Record模式下完全相同的便捷方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ApplicationScoped
public class PersonRepository implements PanacheRepository&lt;Person&gt; {

   // put your custom logic here as instance methods

   public Person findByName(String name){
       return find("name", name).firstResult();
   }

   public List&lt;Person&gt; findAlive(){
       return list("status", Status.Alive);
   }

   public void deleteStefs(){
       delete("name", "Stef");
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>PanacheEntityBase</code> 中定义的所有方法都可以在你的Repository类上使用，所以它使用起来与Active Record模式完全一样，只是你需要注入Repository类的实例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Inject
PersonRepository personRepository;

@GET
public long count(){
    return personRepository.count();
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="最有用的操作-2"><a class="anchor" href="#最有用的操作-2"></a>最有用的操作</h3>
<div class="paragraph">
<p>编写存储库后，您可以执行以下最常见的操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// creating a person
Person person = new Person();
person.setName("Stef");
person.setBirth(LocalDate.of(1910, Month.FEBRUARY, 1));
person.setStatus(Status.Alive);

// persist it
personRepository.persist(person);

// note that once persisted, you don't need to explicitly save your entity: all
// modifications are automatically persisted on transaction commit.

// check if it's persistent
if(personRepository.isPersistent(person)){
    // delete it
    personRepository.delete(person);
}

// getting a list of all Person entities
List&lt;Person&gt; allPersons = personRepository.listAll();

// finding a specific person by ID
person = personRepository.findById(personId);

// finding a specific person by ID via an Optional
Optional&lt;Person&gt; optional = personRepository.findByIdOptional(personId);
person = optional.orElseThrow(() -&gt; new NotFoundException());

// finding all living persons
List&lt;Person&gt; livingPersons = personRepository.list("status", Status.Alive);

// counting all persons
long countAll = personRepository.count();

// counting all living persons
long countAlive = personRepository.count("status", Status.Alive);

// delete all living persons
personRepository.delete("status", Status.Alive);

// delete all persons
personRepository.deleteAll();

// delete by id
boolean deleted = personRepository.deleteById(personId);

// set the name of all living persons to 'Mortal'
personRepository.update("name = 'Mortal' where status = ?1", Status.Alive);</code></pre>
</div>
</div>
<div class="paragraph">
<p>所有 <code>list</code> 方法都有相对应的 <code>stream</code> 版本。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Stream&lt;Person&gt; persons = personRepository.streamAll();
List&lt;String&gt; namesButEmmanuels = persons
    .map(p -&gt; p.name.toLowerCase() )
    .filter( n -&gt; ! "emmanuel".equals(n) )
    .collect(Collectors.toList());</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>stream</code> 方法的运行需要事务。
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
其余的文档只展示了基于活动记录模式的用法，但请记住，这些用法也可以用资源库模式来执行。为了简洁起见，已省略存储库模式示例。
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="高级查询"><a class="anchor" href="#高级查询"></a>高级查询</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="分页"><a class="anchor" href="#分页"></a>分页</h3>
<div class="paragraph">
<p>如果你的表数据量很小，你应该只用到 <code>list</code> 和 <code>stream</code> 方法。对于较大的数据集，你可以使用对应的 <code>find</code> 方法，它返回一个 <code>PanacheQuery</code> ，可以对其进行分页查询操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// create a query for all living persons
PanacheQuery&lt;Person&gt; livingPersons = Person.find("status", Status.Alive);

// make it use pages of 25 entries at a time
livingPersons.page(Page.ofSize(25));

// get the first page
List&lt;Person&gt; firstPage = livingPersons.list();

// get the second page
List&lt;Person&gt; secondPage = livingPersons.nextPage().list();

// get page 7
List&lt;Person&gt; page7 = livingPersons.page(Page.of(7, 25)).list();

// get the number of pages
int numberOfPages = livingPersons.pageCount();

// get the total number of entities returned by this query without paging
long count = livingPersons.count();

// and you can chain methods of course
return Person.find("status", Status.Alive)
    .page(Page.ofSize(25))
    .nextPage()
    .stream()</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>PanacheQuery</code> 类型有许多其他方法来处理分页和返回流。</p>
</div>
</div>
<div class="sect2">
<h3 id="使用range而不是pages"><a class="anchor" href="#使用range而不是pages"></a>使用range而不是pages</h3>
<div class="paragraph">
<p><code>PanacheQuery</code> 也允许基于范围的查询。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// create a query for all living persons
PanacheQuery&lt;Person&gt; livingPersons = Person.find("status", Status.Alive);

// make it use a range: start at index 0 until index 24 (inclusive).
livingPersons.range(0, 24);

// get the range
List&lt;Person&gt; firstRange = livingPersons.list();

// to get the next range, you need to call range again
List&lt;Person&gt; secondRange = livingPersons.range(25, 49).list();</code></pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>你不能混合使用ranges和pages：如果你使用range，所有依赖于拥有当前页面的方法将抛出一个 <code>UnsupportedOperationException</code> ；你可以使用 <code>page(Page)</code> 或 <code>page(int, int)</code> 切换回分页。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="排序"><a class="anchor" href="#排序"></a>排序</h3>
<div class="paragraph">
<p>所有接收查询字符串的方法也能接收以下简化形式的查询：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">List&lt;Person&gt; persons = Person.list("order by name,birth");</code></pre>
</div>
</div>
<div class="paragraph">
<p>这些方法也可以接收一个 <code>Sort</code> 参数，它是对排序的抽象封装：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">List&lt;Person&gt; persons = Person.list(Sort.by("name").and("birth"));

// and with more restrictions
List&lt;Person&gt; persons = Person.list("status", Sort.by("name").and("birth"), Status.Alive);</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>Sort</code> 类有很多方法用于添加列和指定排序方向。</p>
</div>
</div>
<div class="sect2">
<h3 id="简化查询"><a class="anchor" href="#简化查询"></a>简化查询</h3>
<div class="paragraph">
<p>通常情况下，HQL查询语句是这种形式： <code>from EntityName [where &#8230;&#8203;​] [order by &#8230;&#8203;​]</code> ，结尾处有可选元素。</p>
</div>
<div class="paragraph">
<p>如果你的查询语句不是以 <code>from</code> 开始，我们还支持以下的形式：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>order by &#8230;&#8203;</code> 语句会被扩展为： <code>from EntityName order by &#8230;&#8203;</code></p>
</li>
<li>
<p><code>&lt;singleColumnName&gt;</code> (带单个参数）语句会被扩展为： <code>from EntityName where &lt;singleColumnName&gt; = ?</code></p>
</li>
<li>
<p><code>&lt;query&gt;</code> 语句会被扩展为： <code>from EntityName where &lt;query&gt;</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>如果你的更新语句不是以 <code>update</code> 开始，我们还支持以下的形式：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>from EntityName &#8230;&#8203;​</code> 语句会被扩展为： <code>update from EntityName &#8230;&#8203;​</code></p>
</li>
<li>
<p><code>set? &lt;singleColumnName&gt;</code> (带单个参数）语句会被扩展为： <code>update from EntityName set &lt;singleColumnName&gt; = ?</code></p>
</li>
<li>
<p><code>set? &lt;update-query&gt;</code> 语句会被扩展为： <code>update from EntityName set &lt;update-query&gt;</code></p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
你也可以用普通的 <a href="https://docs.jboss.org/hibernate/orm/5.4/userguide/html_single/Hibernate_User_Guide.html#hql">HQL</a> 编写查询语句：
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Order.find("select distinct o from Order o left join fetch o.lineItems");
Order.update("update from Person set name = 'Mortal' where status = ?", Status.Alive);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="命名查询"><a class="anchor" href="#命名查询"></a>命名查询</h3>
<div class="paragraph">
<p>You can reference a named query instead of a (simplified) HQL query by prefixing its name with the '#' character.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Entity
@NamedQuery(name = "Person.getByName", query = "from Person where name = :name")
public class Person extends PanacheEntity {
    public String name;
    public LocalDate birth;
    public Status status;

    public static Person findByName(String name){
        return find("#Person.getByName", name).firstResult();
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>命名查询只能在JPA实体类（必须是Panache实体类，或Repository类的参数化类型）内定义，或在它的父类中定义。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="查询参数"><a class="anchor" href="#查询参数"></a>查询参数</h3>
<div class="paragraph">
<p>你可以通过索引（从1开始）传递查询参数，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Person.find("name = ?1 and status = ?2", "stef", Status.Alive);</code></pre>
</div>
</div>
<div class="paragraph">
<p>或者使用 <code>Map</code> ，按名字来命名：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Map&lt;String, Object&gt; params = new HashMap&lt;&gt;();
params.put("name", "stef");
params.put("status", Status.Alive);
Person.find("name = :name and status = :status", params);</code></pre>
</div>
</div>
<div class="paragraph">
<p>或者使用方便的类 <code>Parameters</code> ，既可以是原样，也可以是建立一个 <code>Map</code> 。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// generate a Map
Person.find("name = :name and status = :status",
         Parameters.with("name", "stef").and("status", Status.Alive).map());

// use it as-is
Person.find("name = :name and status = :status",
         Parameters.with("name", "stef").and("status", Status.Alive));</code></pre>
</div>
</div>
<div class="paragraph">
<p>每个查询操作都接受按索引（ <code>Object&#8230;&#8203;</code> ）或按名称（ <code>Map&lt;String,Object&gt;</code> 或 <code>Parameters</code> ）传递参数。</p>
</div>
</div>
<div class="sect2">
<h3 id="查询映射"><a class="anchor" href="#查询映射"></a>查询映射</h3>
<div class="paragraph">
<p>查询映射可以使用 <code>find()</code> 方法返回的 <code>PanacheQuery</code> 对象上的 <code>project(Class)</code> 方法来完成。</p>
</div>
<div class="paragraph">
<p>你可以用投影限制数据库返回哪些字段。</p>
</div>
<div class="paragraph">
<p>Hibernate会使用 <strong>DTO投影</strong> ，并根据投影的类的属性生成SELECT子句。这也被称为 <strong>动态实例化</strong> 或 <strong>构造器表达</strong> ，更多信息可以在Hibernate指南中找到： <a href="https://docs.jboss.org/hibernate/orm/current/userguide/html_single/Hibernate_User_Guide.html#hql-select-clause">HQL select子句</a></p>
</div>
<div class="paragraph">
<p>投影类必须是有效的Java Bean，并且拥有一个包含所有属性的构造方法，这个构造方法用于实例化投影DTO，而不是使用实体类。这个构造方法必须是唯一的构造方法。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import io.quarkus.runtime.annotations.RegisterForReflection;

@RegisterForReflection <i class="conum" data-value="1"></i><b>(1)</b>
public class PersonName {
    public final String name; <i class="conum" data-value="2"></i><b>(2)</b>

    public PersonName(String name){ <i class="conum" data-value="3"></i><b>(3)</b>
        this.name = name;
    }
}

// only 'name' will be loaded from the database
PanacheQuery&lt;PersonName&gt; query = Person.find("status", Status.Alive).project(PersonName.class);</code></pre>
</div>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>If you plan to deploy your application as a native executable, you must register manually the projection class for reflection.</p>
</li>
<li>
<p>在这里我们使用public的字段，你也可以使用private字段和对应的getter/setter方法。</p>
</li>
<li>
<p>Hibernate会用到这个构造方法，它必须是类中唯一的构造函数，并且包含所有类属性作为参数。</p>
</li>
</ol>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>在 <code>project(Class)</code> 方法的实现中，使用构造函数的参数名来构建查询的select子句，所以编译器必须配置为在编译的类中保留参数名。如果是使用Quarkus Maven archetype创建的项目，该功能默认是启用的。如果你没有使用，请在你的 <code>pom.xml</code> 中添加该属性 <code>&lt;maven.compiler.parameters&gt;true&lt;/maven.compiler.parameters&gt;</code> 。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="多个持久化单元"><a class="anchor" href="#多个持久化单元"></a>多个持久化单元</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The support for multiple persistence units is described in detail in <a href="hibernate-orm#multiple-persistence-units">the Hibernate ORM guide</a>.</p>
</div>
<div class="paragraph">
<p>使用Panache时，事情很简单：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>一个Panache实体类只能配置到一个持久化单元。</p>
</li>
<li>
<p>鉴于此，Panache已经提供了必要的管道， 可以透明地找到Panache实体类对应的 <code>EntityManager</code> 。</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="事务"><a class="anchor" href="#事务"></a>事务</h2>
<div class="sectionbody">
<div class="paragraph">
<p>请确保修改数据库的方法（例如： <code>entity.persist()</code> ）处于同一个事务中。给一个CDI bean方法增加 <code>@Transactional</code> 注解，可以确保该方法即事务边界。我们建议在应用端点的边界这样做，比如REST端点的Controller。</p>
</div>
<div class="paragraph">
<p>JPA将实体的变更进行批量处理，并在事务结束时或查询前发送批量变更（这被称为flush）。这通常更有效率。但是当你想检查乐观锁的失败，即时进行对象验证，或者想得到即时的反馈，你可以通过调用 <code>entity.flush()</code> 或 <code>entity.persistAndFlush()</code> 强制执行flush。JPA向数据库发送这些变更时可能会抛出 <code>PersistenceException</code> ，你可以捕捉这些异常。记住，这样做的效率较低，所以不要滥用它。而且你的事务仍然需要提交。</p>
</div>
<div class="paragraph">
<p>下面是一个使用 flush 方法的例子，它在捕获到 <code>PersistenceException</code> 异常时执行指定操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Transactional
public void create(Parameter parameter){
    try {
        //Here I use the persistAndFlush() shorthand method on a Panache repository to persist to database then flush the changes.
        return parameterRepository.persistAndFlush(parameter);
    }
    catch(PersistenceException pe){
        LOG.error("Unable to create the parameter", pe);
        //in case of error, I save it to disk
        diskPersister.save(parameter);
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="锁管理"><a class="anchor" href="#锁管理"></a>锁管理</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Panache支持在实体类/Repository类中直接使用数据库的锁，可使用 <code>findById(Object, LockModeType)</code> 或 <code>find().withLock(LockModeType)</code> 方法。</p>
</div>
<div class="paragraph">
<p>下面的例子是针对Active Record模式的，但同样可以应用于Repository模式。</p>
</div>
<div class="sect2">
<h3 id="第一通过findbyid方法使用数据库锁"><a class="anchor" href="#第一通过findbyid方法使用数据库锁"></a>第一：通过findById()方法使用数据库锁。</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class PersonEndpoint {

    @GET
    @Transactional
    public Person findByIdForUpdate(Long id){
        Person p = Person.findById(id, LockModeType.PESSIMISTIC_WRITE);
        //do something useful, the lock will be released when the transaction ends.
        return person;
    }

}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="第二通过find方法使用数据库锁"><a class="anchor" href="#第二通过find方法使用数据库锁"></a>第二：通过find()方法使用数据库锁。</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class PersonEndpoint {

    @GET
    @Transactional
    public Person findByNameForUpdate(String name){
        Person p = Person.find("name", name).withLock(LockModeType.PESSIMISTIC_WRITE).findOne();
        //do something useful, the lock will be released when the transaction ends.
        return person;
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，事务结束时锁会被释放，所以调用了带锁查询的方法必须加上 <code>@Transactional</code> 注解。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="自定义id"><a class="anchor" href="#自定义id"></a>自定义ID</h2>
<div class="sectionbody">
<div class="paragraph">
<p>ID往往是一个敏感的话题，并不是所有人都愿意让框架来处理，因此我们提供了相应的配置。</p>
</div>
<div class="paragraph">
<p>你可以通过继承 <code>PanacheEntityBase</code> ，而非 <code>PanacheEntity</code> ，来指定你自己的ID策略。然后只要把你想要的ID字段声明为public字段：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Entity
public class Person extends PanacheEntityBase {

    @Id
    @SequenceGenerator(
            name = "personSequence",
            sequenceName = "person_id_seq",
            allocationSize = 1,
            initialValue = 4)
    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "personSequence")
    public Integer id;

    //...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你使用Repository模式，那么要继承 <code>PanacheRepositoryBase</code> ，而非 <code>PanacheRepository</code> ，并将ID字段类型作为额外的类型参数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ApplicationScoped
public class PersonRepository implements PanacheRepositoryBase&lt;Person,Integer&gt; {
    //...
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="mocking"><a class="anchor" href="#mocking"></a>Mocking</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="使用active-record模式"><a class="anchor" href="#使用active-record模式"></a>使用Active Record模式</h3>
<div class="paragraph">
<p>如果你使用了Active Record模式，那么不能直接使用Mockito，因为它不支持Mock静态方法。你可以使用 <code>quarkus-panache-mock</code> 模块，它允许你使用Mockito来模拟所有静态方法，包括你自己编写的。</p>
</div>
<div class="paragraph">
<p>将此依赖添加到你的 <code>pom.xml</code> 中 ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
    &lt;artifactId&gt;quarkus-panache-mock&lt;/artifactId&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>提供这个简单的实体：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Entity
public class Person extends PanacheEntity {

    public String name;

    public static List&lt;Person&gt; findOrdered() {
        return find("ORDER BY name").list();
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>你可以像这样写你的模拟测试。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@QuarkusTest
public class PanacheFunctionalityTest {

    @Test
    public void testPanacheMocking() {
        PanacheMock.mock(Person.class);

        // Mocked classes always return a default value
        Assertions.assertEquals(0, Person.count());

        // Now let's specify the return value
        Mockito.when(Person.count()).thenReturn(23L);
        Assertions.assertEquals(23, Person.count());

        // Now let's change the return value
        Mockito.when(Person.count()).thenReturn(42L);
        Assertions.assertEquals(42, Person.count());

        // Now let's call the original method
        Mockito.when(Person.count()).thenCallRealMethod();
        Assertions.assertEquals(0, Person.count());

        // Check that we called it 4 times
        PanacheMock.verify(Person.class, Mockito.times(4)).count();<i class="conum" data-value="1"></i><b>(1)</b>

        // Mock only with specific parameters
        Person p = new Person();
        Mockito.when(Person.findById(12L)).thenReturn(p);
        Assertions.assertSame(p, Person.findById(12L));
        Assertions.assertNull(Person.findById(42L));

        // Mock throwing
        Mockito.when(Person.findById(12L)).thenThrow(new WebApplicationException());
        Assertions.assertThrows(WebApplicationException.class, () -&gt; Person.findById(12L));

        // We can even mock your custom methods
        Mockito.when(Person.findOrdered()).thenReturn(Collections.emptyList());
        Assertions.assertTrue(Person.findOrdered().isEmpty());

        // Mocking a void method
        Person.voidMethod();

        // Make it throw
        PanacheMock.doThrow(new RuntimeException("Stef2")).when(Person.class).voidMethod();
        try {
            Person.voidMethod();
            Assertions.fail();
        } catch (RuntimeException x) {
            Assertions.assertEquals("Stef2", x.getMessage());
        }

        // Back to doNothing
        PanacheMock.doNothing().when(Person.class).voidMethod();
        Person.voidMethod();

        // Make it call the real method
        PanacheMock.doCallRealMethod().when(Person.class).voidMethod();
        try {
            Person.voidMethod();
            Assertions.fail();
        } catch (RuntimeException x) {
            Assertions.assertEquals("void", x.getMessage());
        }

        PanacheMock.verify(Person.class).findOrdered();
        PanacheMock.verify(Person.class, Mockito.atLeast(4)).voidMethod();
        PanacheMock.verify(Person.class, Mockito.atLeastOnce()).findById(Mockito.any());
        PanacheMock.verifyNoMoreInteractions(Person.class);
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>请确保是在 <code>PanacheMock</code> 上调用 <code>verify</code> 和 <code>do*</code> 方法，而不是在 <code>Mockito</code> 上调用，否则无法传递mock对象。</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="使用资源库模式"><a class="anchor" href="#使用资源库模式"></a>使用资源库模式</h3>
<div class="paragraph">
<p>如果你使用存储库模式，你可以直接使用Mockito，使用 <code>quarkus-junit5-mockito</code> 模块，这使得模拟Bean变得更加容易：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">&lt;dependency&gt;
    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
    &lt;artifactId&gt;quarkus-junit5-mockito&lt;/artifactId&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>提供这个简单的实体：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Entity
public class Person {

    @Id
    @GeneratedValue
    public Long id;

    public String name;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>还有这个储存库：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ApplicationScoped
public class PersonRepository implements PanacheRepository&lt;Person&gt; {
    public List&lt;Person&gt; findOrdered() {
        return find("ORDER BY name").list();
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>你可以像这样写你的模拟测试。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@QuarkusTest
public class PanacheFunctionalityTest {
    @InjectMock
    PersonRepository personRepository;

    @Test
    public void testPanacheRepositoryMocking() throws Throwable {
        // Mocked classes always return a default value
        Assertions.assertEquals(0, personRepository.count());

        // Now let's specify the return value
        Mockito.when(personRepository.count()).thenReturn(23L);
        Assertions.assertEquals(23, personRepository.count());

        // Now let's change the return value
        Mockito.when(personRepository.count()).thenReturn(42L);
        Assertions.assertEquals(42, personRepository.count());

        // Now let's call the original method
        Mockito.when(personRepository.count()).thenCallRealMethod();
        Assertions.assertEquals(0, personRepository.count());

        // Check that we called it 4 times
        Mockito.verify(personRepository, Mockito.times(4)).count();

        // Mock only with specific parameters
        Person p = new Person();
        Mockito.when(personRepository.findById(12L)).thenReturn(p);
        Assertions.assertSame(p, personRepository.findById(12L));
        Assertions.assertNull(personRepository.findById(42L));

        // Mock throwing
        Mockito.when(personRepository.findById(12L)).thenThrow(new WebApplicationException());
        Assertions.assertThrows(WebApplicationException.class, () -&gt; personRepository.findById(12L));

        Mockito.when(personRepository.findOrdered()).thenReturn(Collections.emptyList());
        Assertions.assertTrue(personRepository.findOrdered().isEmpty());

        // We can even mock your custom methods
        Mockito.verify(personRepository).findOrdered();
        Mockito.verify(personRepository, Mockito.atLeastOnce()).findById(Mockito.any());
        Mockito.verifyNoMoreInteractions(personRepository);
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="我们为什么简化hibernate-orm映射怎么做到的"><a class="anchor" href="#我们为什么简化hibernate-orm映射怎么做到的"></a>我们为什么简化Hibernate ORM映射？怎么做到的？</h2>
<div class="sectionbody">
<div class="paragraph">
<p>在编写Hibernate ORM实体类时，用户已经习惯了被迫处理许多烦人的事情，例如：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>重复ID逻辑：大多数实体需要一个ID，大多数人并不关心它是如何设置的，因为它与你的模型并不真正相关。</p>
</li>
<li>
<p>繁琐的 getters 和 setters：由于Java语言中缺乏对属性的支持，我们必须创建字段，然后为这些字段getters 和 setters，即使它们除了read/write字段外实际上没有做任何事情。</p>
</li>
<li>
<p>传统的EE模式建议将实体定义（模型）与你可以对其进行的操作（DAO、Repositories）分开，但实际上这需要在状态和其操作之间进行不自然的分割，尽管在面向对象的架构中，我们永远不会对普通对象做这样的事情，因为状态和方法是在同一个类中。此外，这需要每个实体有两个类，并且需要在你需要进行实体操作的地方注入DAO或Repository，这就破坏了你的编辑流程，需要你从正在编写的代码中跳出来，建立一个注入点，然后再回来使用它。</p>
</li>
<li>
<p>Hibernate查询功能很强大，但对于普通操作来说过于冗长，即使是简单操作也要求写完整的HQL语句。</p>
</li>
<li>
<p>Hibernate很通用，但对于模型里90%的琐碎操作，编写起来并不简单。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>通过Panache，我们采取了一种有主见的方法来解决所有这些问题：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>让你的实体类继承 <code>PanacheEntity</code> ：它有一个自动生成的ID字段。如果你需要自定义ID策略，可以继承 <code>PanacheEntityBase</code> ，而不用自己处理ID。</p>
</li>
<li>
<p>使用公共字段。摆脱繁琐的getter和setters。在后台，我们将生成所有缺失的getter和setter，并重写对这些字段的每个访问，以使用访问器方法。这样，当你需要时，你仍然可以写出 <em>有用的</em> 访问器，即使你的实体用户仍然使用字段访问，也会被使用。</p>
</li>
<li>
<p>使用活动记录模式：把你所有的实体逻辑放在实体类的静态方法中，不要创建DAO。你的实体超类带有很多超级有用的静态方法，你也可以在你的实体类中添加你自己的静态方法。用户可以通过输入 <code>Person.</code> ，开始使用你的实体 <code>Person</code> ，并在一个地方获得所有操作的完成。</p>
</li>
<li>
<p>不要写多余的查询语句：可以写 <code>Person.find("order by name")</code> 或 <code>Person.find("name = ?1 and status = ?2", "stef", Status.Alive)</code> ，甚至更好的 <code>Person.find("name", "stef")</code> 。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>以上就是它的全部内容：有了Panache，Hibernate ORM看起来变得如此轻量和整洁。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="在外部项目或jar中定义实体"><a class="anchor" href="#在外部项目或jar中定义实体"></a>在外部项目或jar中定义实体</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Hibernate ORM Panache依赖于编译时对实体类的字节码增强。</p>
</div>
<div class="paragraph">
<p>它试图通过标记文件 <code>META-INFpanache-archive.marker</code> 的存在来识别具有 Panache 实体（和 Panache 实体的消费者）的档案。 Panache 包含一个注释处理器，它将自动在依赖于 Panache（甚至间接）的档案中创建此文件。如果您禁用了注释处理器，在某些情况下您可能需要手动创建此文件。</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
如果你的项目包含 jpa-modelgen 注解处理器，则默认情况下会排除 Panache 注解处理器。这种情况下，你应该自己创建标记文件，或者添加 <code>quarkus-panache-common</code> 插件，如下所示：
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;plugin&gt;
    &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
    &lt;version&gt;${compiler-plugin.version}&lt;/version&gt;
    &lt;configuration&gt;
      &lt;annotationProcessorPaths&gt;
        &lt;annotationProcessorPath&gt;
          &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
          &lt;artifactId&gt;hibernate-jpamodelgen&lt;/artifactId&gt;
          &lt;version&gt;${hibernate.version}&lt;/version&gt;
        &lt;/annotationProcessorPath&gt;
        &lt;annotationProcessorPath&gt;
          &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
          &lt;artifactId&gt;quarkus-panache-common&lt;/artifactId&gt;
          &lt;version&gt;${quarkus.platform.version}&lt;/version&gt;
        &lt;/annotationProcessorPath&gt;
      &lt;/annotationProcessorPaths&gt;
    &lt;/configuration&gt;
&lt;/plugin&gt;</code></pre>
</div>
</div>
</div>
</div>
    </div>
  </div>
</div>

  </div>

  <div class="content project-footer">
  <div class="footer-section">
    <div class="logo-wrapper">
      <a href="/"><img src="/assets/images/quarkus_logo_horizontal_rgb_reverse.svg" class="project-logo" title="Quarkus"></a>
    </div>
  </div>
  <div class="grid-wrapper">
    <p class="grid__item width-3-12">Quarkus是开放的。这个项目的所有依赖关系在<a href='https://www.apache.org/licenses/LICENSE-2.0' target='_blank'>Apache Software License 2.0</a>许可或者可以在有互换性的许可下使用。<br /><br />这个网站使用 <a href='https://jekyllrb.com/' target='_blank'>Jekyll</a> 来构建，代码托管于<a href='https://pages.github.com/' target='_blank'>Github Pages</a>，完全开源。当需要改善和丰富内容的时候，我们会从 <a href='https://github.com/quarkusio/quarkusio.github.io' target='_blank'>网站项目</a>创建分支，然后修正并发布到网站。</p>

    
      <div class="width-1-12 project-links">
        <span>导航栏</span>
        <ul class="footer-links">
          
            <li><a href="/">主页</a></li>
          
            <li><a href="/about">关于Quarkus</a></li>
          
            <li><a href="/blog">博客</a></li>
          
            <li><a href="/insights">播客</a></li>
          
            <li><a href="/events">活动</a></li>
          
            <li><a href="/newsletter">新闻</a></li>
          
            <li><a href="/publications">发表</a></li>
          
            <li><a href="/awards">获奖</a></li>
          
            <li><a href="/security">安全</a></li>
          
        </ul>
      </div>
    
      <div class="width-1-12 project-links">
        <span>社交媒体</span>
        <ul class="footer-links">
          
            <li><a href="https://twitter.com/quarkusio">Twitter</a></li>
          
            <li><a href="https://www.facebook.com/quarkusio">Facebook</a></li>
          
            <li><a href="https://www.linkedin.com/company/quarkusio/">Linkedin</a></li>
          
            <li><a href="https://www.youtube.com/channel/UCaW8QG_QoIk_FnjLgr5eOqg">Youtube</a></li>
          
            <li><a href="https://github.com/quarkusio">GitHub</a></li>
          
        </ul>
      </div>
    
      <div class="width-2-12 project-links">
        <span>协助</span>
        <ul class="footer-links">
          
            <li><a href="/support">支持</a></li>
          
            <li><a href="/guides">指南</a></li>
          
            <li><a href="/faq">FAQ</a></li>
          
            <li><a href="/get-started">入门</a></li>
          
            <li><a href="https://stackoverflow.com/questions/tagged/quarkus">Stack Overflow</a></li>
          
            <li><a href="https://github.com/quarkusio/quarkus/discussions">讨论</a></li>
          
            <li><a href="https://groups.google.com/forum/#!forum/quarkus-dev">开发邮件列表</a></li>
          
        </ul>
      </div>
    
      <div class="width-1-12 project-links">
        <span>Languages</span>
        <ul class="footer-links">
          
            <li><a href="https://quarkus.io/">English</a></li>
          
            <li><a href="https://es.quarkus.io/">Español</a></li>
          
            <li><a href="https://ja.quarkus.io/">日本語</a></li>
          
            <li><a href="https://cn.quarkus.io/">简体中文</a></li>
          
        </ul>
      </div>
    

    
      <div class="width-4-12 more-links">
        <span>Quarkus由社区项目组成：</span>
        <ul class="footer-links">
          
            <li><a href="https://vertx.io/" target="_blank">Eclipse Vert.x</a></li>
          
            <li><a href="https://smallrye.io" target="_blank">SmallRye</a></li>
          
            <li><a href="https://hibernate.org" target="_blank">Hibernate</a></li>
          
            <li><a href="https://netty.io" target="_blank">Netty</a></li>
          
            <li><a href="https://resteasy.github.io" target="_blank">RESTEasy</a></li>
          
            <li><a href="https://camel.apache.org" target="_blank">Apache Camel</a></li>
          
            <li><a href="https://microprofile.io" target="_blank">Eclipse MicroProfile</a></li>
          
            <li><a href="https://code.quarkus.io/" target="_blank">更多...</a></li>
          
        </ul>
      </div>
    
  </div>
</div>

  <div class="content redhat-footer">
  <div class="grid-wrapper">
    <span class="licence">
      <i class="fab fa-creative-commons"></i><i class="fab fa-creative-commons-by"></i> <a href="https://creativecommons.org/licenses/by/3.0/" target="_blank">CC by 3.0</a> | <a href="https://www.redhat.com/en/about/privacy-policy">Privacy Policy</a>
    </span>
    <span class="redhat">
      Sponsored by
    </span>
    <span class="redhat-logo">
      <a href="https://www.redhat.com/" target="_blank"><img src="/assets/images/redhat_reversed.svg"></a>
    </span>
  </div>
</div>


  <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.4/jquery.min.js" integrity="sha384-8gBf6Y4YYq7Jx97PIqmTwLPin4hxIzQw5aDmUg/DDhul9fFpbbLcLh3nTIIDJKhx" crossorigin="anonymous"></script>
  <script type="text/javascript" src="/assets/javascript/mobile-nav.js"></script>
  <script type="text/javascript" src="/assets/javascript/scroll-down.js"></script>
  <script src="/assets/javascript/satellite.js" type="text/javascript"></script>
  <script src="/guides/javascript/config.js" type="text/javascript"></script>
  <script src="/assets/javascript/search-filter.js" type="text/javascript"></script>
  <script src="/assets/javascript/guides-version-dropdown.js" type="text/javascript"></script>
  <script src="/assets/javascript/back-to-top.js" type="text/javascript"></script>
  <script src="/assets/javascript/clipboard.min.js" type="text/javascript"></script>
  <script src="/assets/javascript/copy.js" type="text/javascript"></script>
  <script src="/assets/javascript/asciidoc-tabs.js" type="text/javascript"></script>
</body>

</html>
